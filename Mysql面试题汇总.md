# Mysql面试题汇总

#### 1.MySQL redo/undo日志作用

redo log（重做日志），提供前滚操作，通常是物理日志，记录的是数据页的物理修改，用来恢复提交后的物理数据页，且通常只能恢复到最后一次提交的位置。用来确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘，在重启MySQL服务时，根据redo log进行重做，从而达到事务的持久性。

undo log（回滚日志），提供回滚操作，一般是逻辑日志，根据每行记录进行记录，保存了事务发生前数据的一个版本，可以用于回滚，同时也可以提供多版本并发控制下的读。

`undo log`不是`redo log`的逆向过程，其实它们都算是用来恢复的日志

#### 2.MySQL 二进制日志文件binlog原理

二进制文件包含了引起或可能引起数据库改变的事件信息，但是绝对不包括select和show这样的查询语句。二进制文件以事件形式记录。

二进制日志文件作用：

- 恢复：
- 复制：
- 审计：用户可以通过二进制日志文件判断是否有对数据库进行注入的攻击。

二进制日志文件在默认情况下并没有启动。

二进制日志是mysql数据库级别的日志，记录相关的更改操作。Redo日志是InnoDB表级别的日志

#### 3.MYSQL有哪些引擎，有什么区别

主要有InnoDB、MyISAM、MEMORY、MERGE、ARCHIVE

InnoDB：支持事务、支持行锁、支持外键约束，有MVCC保证高并发，有间隙锁来防止幻读。采用聚簇索引，必须指定主键，如不指定会自动生成六字节的rowid作为主键。

MyISAM：拥有较高的插入和查询能力，不支持事务，仅支持表级锁。索引和数据是分开的，叶子节点存储的都是数据指针。相比InnoDB其缓存在内存中的是索引而不带数据的。其用一个变量保存了整个表的行数，select count(*)时会读取这个变量而不是遍历全表。支持全文索引。并且可以没有主键

MEMORY：逻辑存储介质是内存，使用的存储类型必须是定长的，因此不支持Bolb和Text类型。支持哈希索引。

MERGE：是一组MyISAM表的组合，这些MyISAM表必须完全相同。可以实现分表。日志使用这种引擎较多

ARCHIVE：Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。只支持插入和查询。mysql5.5后支持索引。

#### 4.MySQL有哪些索引，具体说说每种索引

索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

##### 1.B-Tree索引

大多数MySQL存储引擎默认的索引类型

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

<img src="https://camo.githubusercontent.com/68aaad622e8561419c29c6a0a37ab7bb53c10d14/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67" alt="img" style="zoom:67%;" />

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

<img src="https://camo.githubusercontent.com/dd47755ce0994df42de07ee39f185aa53c3af3bc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67" alt="img" style="zoom:67%;" />

##### 2.哈希索引

只有Memory引擎支持

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

##### 3.全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

##### 4.空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

#### 5.聚簇索引与非聚簇索引

聚簇索引并非一种单独的数据类型，而是一种数据存储方式，具体细节依赖于实现形式，InnoDB中的聚簇索引实际上是在同一个结构中保存了B+Tree索引和数据行。

当表中有聚簇索引时，它的数据实际上存储在索引的叶子页中（叶子页包含了行的全部数据），而非聚簇索引的B+Tree索引中存放的是指向数据的指针（页是MySQL存储引擎最小的存储单元）。

InnoDB存储引擎通过主键聚集数据(聚簇索引)，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有唯一索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

MyISAM中主键索引和其他索引 都指向物理行 (非聚簇索引)

区别：

聚簇索引，索引的顺序就是数据存放的顺序（物理顺序），只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。一张数据表只能有一个聚簇索引。（一个数据页中数据物理存储是有序的）

非聚簇索引通过叶子节点指针找到数据页中的数据，所以非聚簇索引是逻辑顺序。

#### 6.使用索引的注意事项，什么情况下使用索引（索引创建原则）

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

#### 7.索引什么时候会失效 

- 查询条件中有“or”
- like查询以'%'开头
- 查询列上有运算或者函数的
- 如果列类型是字符串，则一定要在条件中把数据用引号引起来，否则不使用索引
- 左连接查询或右连接查询关联的字段编码格式不一致
- 如果MySQL估计全表扫描比使用索引要更快，则不使用索引
- 连接查询中，按照优化器顺序的第一张表不会走索引
- 如果查询中没有用到联合索引的第一个字段，就不会走索引

#### 8.索引为什么用B+树而不是B树

首先选用B树是因为，相比其他树（红黑或平衡二叉树），B树每个节点可以存放多个值，可以降低树的高度，也就可以减少IO的次数。

其次，由于B树在非叶子节点上也会存储值，这会导致向下查询的时候，每次读入的节点会带有大量的数据，导致IO开销增加。而B+树所有的数据都在节点，因此再向下查找过程中不会有过多的IO开销。

最后，使用B+树可以将所有叶节点使用一条链表串起来，方便进行数据遍历查询。

#### 9.MYSQL事务特性

ACID：原子性、一致性、隔离性、持久性

原子性：一个事务要么全做，要么全不做；

一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏

隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务的四个隔离级别：未提交读、提交读、可重复读、串行化

持久性：事务提交结束后，对数据的修改是永久的。

#### 10.MySQL是如何实现RR(可重复读)和RC(提交读)的？

InnoDB在实现MVCC的时候用到一致性视图，用于支持**可重复读**（事务启动时候拍快照ReadView）和**提交读**（每次执行select拍快照ReadView）隔离级别；

#### 11.如何解决幻读

间隙锁

临键锁：行锁+间隙锁，即临键锁是是一个左开右闭的区间

InnoDB的默认事务隔离级别是RR，在这种级别下，如果你使用select ... in share mode或者select ... for update语句，那么InnoDB会使用临键锁，因而可以防止**幻读**；但即使你的隔离级别是RR，如果你这是使用普通的select语句，那么InnoDB将是快照读，不会使用任何锁，因而还是无法防止**幻读**。

#### 12.MVCC多版本并发控制，如何实现可重复读

ReadView（可读视图）

#### 13.MYSQL中的锁机制、行锁、间隙锁

行锁：一定是用在索引上的

间隙锁：一定是一个开区间，间隙锁不互斥，间隙锁本质上是用于**阻止其他事务在该间隙内插入新记录**，而**自身事务是允许在该间隙内插入数据的**。也就是说间隙锁的应用场景包括并发**读取**、并发**更新**、并发**删除**和并发**插入**。间隙锁只有在RR（可重复读）中才有。

#### 14.乐观锁与悲观锁

悲观锁(Pessimistic Locking)，悲观锁是指在数据处理过程，使数据处于锁定状态，一般使用数据库的锁机制现。

**select...for update**是MySQL提供的实现悲观锁的方式，**在MySQL中用悲观锁务必须确定走了索引，而不是全表扫描，否则将会将整个数据表锁住**。

乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做。

利用数据版本号（**version**）机制是乐观锁最常用的一种实现方式。一般通过为数据库表增加一个数字类型的 “version” 字段，当读取数据时，将version字段的值一同读出，数据每更新一次，对此**version值+1**。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，返回更新失败。

<img src="https://upload-images.jianshu.io/upload_images/4461377-d7472568e615e335.png?imageMogr2/auto-orient/strip|imageView2/2/w/741/format/webp" alt="img" style="zoom:67%;" />

#### 15.数据库三大范式

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。

第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。

第三范式：任何非主属性不依赖于其它非主属性。