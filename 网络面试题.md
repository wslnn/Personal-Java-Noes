# 网络面试题

#### 1.TCP三次握手和四次挥手，为什么挥手等待2MSL

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。

<img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5791ba3163716?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:67%;" />

**三次握手**

（1）第一次握手

客户端发送syn包（seq = x）到服务器，并进入SYN_SENT状态，等待服务器确认

（2）第二次握手

服务器收到syn包，必须确认客户端的syn包（ACK = x+1），同时自己也发送一个syn包（seq = y），即SYN+ACK，此时服务器进入SYN_RCVD状态

（3）第三次握手

客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK= y+1），此包发送完毕，客户端和服务器都进入ESTABLISHED状态，三次握手完成。

为什么需要三次握手：

客户端和服务器端通信前需要连接，而”握手“作用就是为了证明，**客户端的发送能力和服务器端的接受能力都是正常的，**这是”握手“来达到的目的。

**四次挥手**

TCP是半关闭协议（half-close），允许单边连接存在。因此，每个方向必须单独地广播连接。收到一个FIN只意味着这一方向上没有数据流动。

**（1）第一次挥手**

客户端主动关闭方发送一个FIN，用来关闭客户端到服务器端的数据传送，也就是客户端告诉服务器端：我已经不会再给你发数据了， (当然，在 fin 包之前发送出去的数据，如果没有收到对应的 ack 确认报文，客户端依然会重发这些数据)，**但是，此时客户端还可以接受数据**。

**（2）第二次挥手**

服务端收到FIN包后，发送一个ACK给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。

**（3）第三次挥手**

服务器端发送一个FIN，用来关闭服务器端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发送数据了！！！

**（4）第四次挥手**

客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号 + 1，至此，完成四次挥手。

<img src="https://user-gold-cdn.xitu.io/2019/9/22/16d57b8a4bef4f3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom: 80%;" />

**为什么挥手等待2MSL**

TIME_WAIT状态也称为2MSL状态。MSL（Maximum Segment Lifetime）指的是TCP段在被丢弃前在网络中的最长时间。

- 保证旧连接的数据包消失在网络中，不影响新的连接
- 超时重传。若ACK丢失，可处理对方重发的FIN断开连接请求。

#### 2.TCP/UDP区别

![image-20201020143413455](C:\Users\hply\AppData\Roaming\Typora\typora-user-images\image-20201020143413455.png)

#### 3.TCP的拥塞控制和流量控制

TCP采用滑动窗口做流量控制。TCP头里有一个字段叫Window（或Advertised Window），*用于接收方通知发送方自己还有多少缓冲区可以接收数据*。**发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，是谓流量控制**。

`rwnd`（Receiver Window，接收者窗口）：

- rwnd是用于流量控制的窗口大小，即上述流量控制中的AdvertisedWindow，主要取决于接收方的处理速度，由接收方通知发送方被动调整

**拥塞控制**

cwnd（Congestion Window，拥塞窗口）:用于拥塞处理的窗口大小，取决于网络状况，由发送发探查网络主动调整。

**拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量**。主要使用4种算法完成拥塞控制：

- 慢启动

  `慢启动算法`（Slow Start）作用在拥塞产生之前：*对于刚刚加入网络的连接，要一点一点的提速，不要妄图一步到位*。如下：

  连接刚建好，初始化cwnd = 1（当然，通常不会初始化为1，太小），表明可以传一个MSS大小的数据。

  每收到一个ACK，cwnd++，线性增长。

  每经过一个RTT，cwnd = cwnd * 2，指数增长（主要增长来源）。

  还有一个ssthresh（slow start threshold）慢启动门限，当cwnd >= ssthresh时，就会进入拥塞避免算法

- 拥塞避免

  拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

  无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕

  ![img](https://user-gold-cdn.xitu.io/2018/5/28/163a4bb7b0cd6401?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 快速重传

  快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图

  ![img](https://user-gold-cdn.xitu.io/2018/5/28/163a4bb7b0608b65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 快速恢复

当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法
考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno版本是目前使用最广泛的版本。

![img](https://user-gold-cdn.xitu.io/2018/5/28/163a4bb7b076fc73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 4.超时重传和快速重传，拥塞窗口的变化是否相同？

慢启动与拥塞避免算法作用在拥塞发生前，采取不同的策略增大cwnd；如果已经发生拥塞，则需要采取策略减小cwnd。那么，TCP如何判断当前网络拥塞了呢？很简单，**如果发送方发现有Seq发送失败（表现为“丢包”），就认为网络拥塞了**。

丢包后，有两种重传方式，对应不同的网络情况，也就对应着两种拥塞发生时的控制算法：

1. 超时重传。TCP认为这种情况太糟糕，调整力度比较大：
   1. ssthresh =  cwnd /2
   2. cwnd = 1，重新进入慢启动过程（网络糟糕，要慢慢调整）
2. 快速重传。因为收到了好几个重复的确认，TCP认为这种情况通常比RTO超时好一些，主流实现TCP Reno的调整力度更柔和：
   1. ssthresh =  cwnd /2
   2. cwnd = cwnd /2，进入快速恢复算法（网络没那么糟，可以快速调整）

#### 5.HTTP报文格式

HTTP报文是简单的格式化数据块，是用于文本传输的数据字符串，由三部分构成：对报文描述的起始行、包含属性的首部、包含数据的主体。

HTTP报文可以分为两类：请求报文和响应报文

#### 6.HTTP方法：get、post

get:从服务器获取一份资源，不包含主体

post：向服务器发送需要处理的数据，包含主体

#### 7.HTTP状态码

- 1xx

  100 Continue

- 2xx 成功

- 3xx 重定向

- 4xx 客户端错误

- 5xx 服务端错误

#### 8.浏览器输入域名到显示页面的过程

- 要解析域名转换成对应的公网IP；
- 根据公网IP通过庞大的互联网路由到对应的服务器上；
- 建立可靠的TCP数据连接
- 服务器对该URL中的请求进行处理分发，返回一个html；
- 浏览器或者客户端对该HTML进行渲染；